---
title: "NEURON Assignment"
author: "Sarah Olesen, Tim Sit"
date: \today
output:
  pdf_document:
    number_sections: yes
  html_notebook: default
  html_document:
    df_print: paged
toc: yes
---

```{r setup, include = TRUE, echo = FALSE}
library(reticulate)
# use_python("/home/timothysit/anaconda3/envs/NEURON/bin/python3.6")
use_condaenv(condaenv = "NEURON", required = TRUE)
```

```{r, echo = FALSE}
# wrap code 
library(knitr)
opts_chunk$set(tidy.opts=list(width.cutoff=50),tidy=TRUE)
```

```{r, echo = FALSE}
# modifying spacing between figure and text or code 
if(is_latex_output()) {
  plot_default <- knit_hooks$get("plot")
  knit_hooks$set(plot = function(x, options) { 
    x <- c(plot_default(x, options), "\\vspace{25pt}")
  })
}
```



```{python, echo = FALSE}
import seaborn as sns 
import matplotlib.pyplot as plt
# plot settings 
def aesthetics(font_scale = 2, line_width = 5):
    import matplotlib as mpl
    mpl.rcParams['figure.dpi']= 300
    sns.set_context("notebook", font_scale= font_scale, 
                    rc={"lines.linewidth": line_width})
    sns.set_style('white')
    # label with LaTeX rendering
    plt.rc('text', usetex=True)
    plt.rc("axes.spines", top=False, right=False)
    
    # change colormap 
    mpl.rcParams['image.cmap'] = 'viridis'
    
aesthetics()
```

```{python, echo = FALSE}
# change QT path (otherwise Rstudio will abort whenever it tries to plot)
import os
os.environ['QT_QPA_PLATFORM_PLUGIN_PATH'] = "/home/timothysit/anaconda3/envs/NEURON/plugins/platforms"
```

# Passive properties 

## Make a ball model and measure $R_i$, $m_\tau$ with current injection 

We first define a function which injects current into a cell with passive properties, whilst recording voltage. The function returns the recorded voltage and time vectors.

```{python}
from neuron import h, gui
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

# default somalength = 100
# default soma diam = 500 
def inject_current(cell, somaLength = 12.54, somaDiam = 12.54, 
                   stimDur = 10, stimAmp = 0.05, stimDelay = 10, total_time = 25, 
                   g_pas = 0.001,
                  printProperties = False): 
    """
    Injects current to a cell and measure the voltage over time
    INPUT 
    somaLength      | length of the soma (um)
    somaDiam        | diameter of the soma 
    stimDur         | duration of the stimulus (ms)
    stimAmp         | amplitude of current injection (pA)
    stimDelay       | delay before the stimulus is given (ms)
    total_time      | total time of the simulation 
    printProperties | if true, print the properties of the cell 
    OUTPUT 
    voltage 
    time
    """
    
    cell.insert('pas')
    cell.L = somaLength 
    cell.diam = somaDiam
    cell.g_pas = g_pas
    
    if printProperties is True:
        print('Cell properties')
        h.psection()
    
    # add point process: current injection 
    stim = h.IClamp(cell(0.5))
    stim.delay = stimDelay
    stim.dur = stimDur # ms
    stim.amp = stimAmp # nA

    # measure voltage
    voltage = h.Vector() 
    voltage.record(cell(0.5)._ref_v)
    
    # measure time
    time = h.Vector()
    time.record(h._ref_t)
    
    h.v_init = -70 # initial voltage
    h.load_file('stdrun.hoc')
    h.tstop = total_time
    h.run() # ms
    
    # time_np = time.as_numpy() # WARNING: don't output values with .as_numpy()
    # voltage_np = voltage.as_numpy()
    return voltage, time
```

We define a function (using Ohms law) which allows us to calculate the input resistance ($R_i$) from our cell recording using the returned voltage vector and the known amplitude of our current injection.

$$
R_i = \frac{\Delta V}{\Delta I_e}
$$

```{python}
def cal_Ri(voltage_np, stimAmp = 0.05):
    
    delta_V = (max(voltage_np) - min(voltage_np)) * 10**(-3) # millivolts (mV)
    delta_Ie = stimAmp * 10**(-9) # nanoAmps
    input_resistance = delta_V / delta_Ie
    
    return input_resistance
```

We also define a function to calculate the membrane time constant $\tau_m$ from our recording. We are doing this by finding the time when the voltage has reached 63.2% of its peak voltage.

```{python}
def find_nearest(array, value):
    array = np.asarray(array)
    idx = (np.abs(array - value)).argmin()
    return array[idx]

def cal_TauM(voltage, time, stimDelay = 10):
    # convert voltage to numpy 
    voltage_np = voltage.as_numpy()
    time_np = time.as_numpy()
    # from "experiment"
    special_v = (max(voltage_np) - min(voltage_np)) * (1 - 1/np.e) # about 2/3 
    assert(special_v > 0)
    special_vv = special_v + min(voltage_np)
    
    # create trimmed voltage_np to ensure find_nearest finds only 
    # within the 'charging' curve
    firstMaxIndex = np.where(voltage_np == max(voltage_np))
    firstMaxIndex = firstMaxIndex[0][0]
    voltage_np_trim = voltage_np[0:firstMaxIndex]

    tauIndex = np.where(voltage_np_trim == find_nearest(voltage_np_trim, special_vv))
    if tauIndex[0].size > 1: # more than one matching value
        tau_m_samp = tauIndex[0][0]
    else: 
        tau_m_samp = tauIndex[0]

    tau_m_exp = time_np[tau_m_samp]
    TauM = tau_m_exp - stimDelay
    
    return TauM[0]
```

We run our current injection function on a cell which only contains a soma. According to the default settings of our function the soma diameter and length are the same, creating a ball.
Below is a plot of the voltage recorded during current injection into our ball model, which has the expected waveform of a cell with passive properties.

```{python, fig.width=10, fig.height = 7}
voltage, time = inject_current(cell = h.Section(name='soma'))

# plt.figure(figsize=(8, 4))
# ax = sns.lineplot(time, voltage)
plt.figure()
plt.plot(time, voltage)
plt.title('Current injection to passive ball model')
plt.xlabel('Time (ms)')
plt.ylabel('Potential difference (V)')
plt.show()
# ax.set_title('Current injection to passive ball model')
# ax.set(xlabel='Time (ms)', ylabel='Potential difference (V)')

input_resistance = cal_Ri(voltage)
# print('Input resistance is %.2f ohms' % input_resistance)
print('Input resistance is %.2f Mohms' % (input_resistance / 10**6))

TauM = cal_TauM(voltage, time)
print('TauM is %.2f ms' % TauM)
```
The input resistance in our cell is quite high because our cell is rather small. During our in vitro experiments this week we measured our input resistance to be around 5 Mohms.
Our calculated time constant is 1 ms, this correlates well with the observed voltage change plotted above.


## Varying neuron variables

Change diameter, $R_m$, $R_a$, $C_m$ and see how it affects $R_i$ and $m_\tau$

We generate lists containing different values for the above mentioned variables.
We first show how changes in diameter effect the recorded voltage, and then the effects of diameter on $R_i$ and $\tau_m$.

```{python, fig.width=10, fig.height = 7}
g_list = [0.001, 0.01, 0.1, 1, 10]
Ra_list = [10, 20, 30, 40, 50] # default is 35.4 
diam_list = [300, 600, 900, 1200, 1500] # default is 500
Cm_list = [0.1, 0.3, 0.6, 1.0, 1.3] # default is 1
# circum =  soma.diam  * np.pi 
# length = soma.L
# A_list = (circum * 10**(-6)) * (length * 10 ** (-6)) 

input_resistance_list = list()
TauM_list = list()

# colormap 
import matplotlib.pylab as pl
num_color = len(diam_list)
colors = pl.cm.viridis(np.linspace(0,1,num_color))

plt.figure()
for diam, n in zip(diam_list, np.arange(num_color)):
    voltage_np, time_np = inject_current(cell = h.Section(name='soma'), 
                                         somaLength = 12.6157,
                                         somaDiam = diam, 
                                         stimDur = 10, 
                                         stimAmp = 0.05, 
                                         stimDelay = 10)
    input_resistance_list.append(cal_Ri(voltage_np))
    TauM_list.append(cal_TauM(voltage_np, time_np))
    # plot voltage over time 
    plt.plot(time_np, voltage_np, 
             label = diam, 
             color = colors[n])
    

plt.ylabel('Membrane potential (mV)')
plt.xlabel('Time (ms)')
plt.legend(frameon=False, title = 'Diameter ($\mu$m)')
plt.show()
```

From the above plot we can see that the voltage change following current injection is larger in a cell with a smaller diameter.
We will thus expect (according to Ohms law) that the cell with the smallest diameter will have the largest $R_i$, resulting in a larger voltage change.

### Variation of input resistance and time constant with diameter

```{python, fig.width = 15, fig.height = 7}
import seaborn as sns 
aesthetics()
plt.figure()
plt.subplot(1, 2, 1)
ax = sns.lineplot(diam_list, input_resistance_list)
plt.xlabel('Diameter ($\mu$m)')
plt.ylabel('Input resistance ($\Omega$)')

plt.subplot(1, 2, 2)
# time constant vs. diameter 
ax2 = sns.lineplot(diam_list, TauM_list)
plt.xlabel('Diameter ($\mu$m)')
plt.ylabel('Time constant (ms)')

plt.show() 
```

Indeed we observe that the $R_i$ is highest in the cell with the smallest diameter, and decreases as diameter increases.

Diameter however does not have an effect on $\tau_m$.
When we increase the diameter we increase our total amount of membrane and as a consequence the capacitance of the cell increases proportionally.
We also know that membrane resistance is dependent on area and input resistance since:
$$
R_i = \frac{R_m}{\A}
$$
As illustrated above the $R_i$ decreases with increased diameter, and as a consequence $R_m$ also decreases when we make the cell larger.
So both $R_m$ and $C_m$ change but they cancel each other out resulting in no net change in the time constant.



#### Holding all variables except one
We now calculate $R_i$ and $\tau_m$ in situation varying other parameters.

```{python}
# second approach 
# holding everything else in their default values, then varying one variable 
# use multiple y-axis for visualisation 
Ra_default = 35.4 # uOhm 
diam_default = 500 # uM 
Cm_default = 1 # uF/cm^2 
g_pas_default = 0.001

Ra_list = [10, 20, 30, 40, 50]
diam_list = [500, 600, 700, 800, 900]
Cm_list = [1.1, 1.2, 1.3, 1.4, 1.5]
gpas_list = [0.001, 0.002, 0.003, 0.004, 0.005]

# colormap 
# this assumes all the list have the same length
import matplotlib.pylab as pl
num_color = len(Ra_list)
colors = pl.cm.viridis(np.linspace(0,1,num_color))

Ri_Ra_list = list()
Ri_diam_list = list()
Ri_Cm_list = list()
Ri_gpas_list = list()

mTau_Ra_list = list()
mTau_diam_list = list()
mTau_Cm_list = list()
mTau_gpas_list = list()

fig, ax = plt.subplots(nrows = 4, ncols = 1, figsize = (12, 20))
fig.text(0.5, 0.04, 'Time (ms)', ha='center')
fig.text(0.04, 0.5, 'Potential difference (mV)', ha='center', rotation = 'vertical')

# ideally, the plotting should be done in Object-oriented approach instead

plt.xlabel('Time (ms)')
ax1 = plt.subplot(4, 1, 1)
plt.title('Varying axial resistance ($\Omega$)')
# the effect of axial resistance on input resistance and time constant
for Ra, n in zip(Ra_list, np.arange(num_color)):
    cell = h.Section(name = 'cell')
    cell.Ra = Ra
    diam = diam_default
    cell.cm = Cm_default
    voltage, time = inject_current(cell = cell, somaLength = 12.6157,
somaDiam = diam, stimDur = 10, stimAmp = 0.05, stimDelay = 10)
    Ri_Ra_list.append(cal_Ri(voltage))
    mTau_Ra_list.append(cal_TauM(voltage, time))
    plt.plot(time, voltage, 
    label = Ra, color = colors[n])
    plt.legend(frameon = False)

ax1 = plt.subplot(4, 1, 2)
plt.title('Varying diameter ($\mu$m)')
# the effect of diameter on input resistance and time constant
for diam, n in zip(diam_list, np.arange(num_color)):
    cell = h.Section(name = 'cell')
    cell.Ra = Ra_default
    diam = diam
    cell.cm = Cm_default
    voltage, time = inject_current(cell = cell, somaLength = 12.6157,
somaDiam = diam, stimDur = 10, stimAmp = 0.05, stimDelay = 10)
    Ri_diam_list.append(cal_Ri(voltage))
    mTau_diam_list.append(cal_TauM(voltage, time))
    plt.plot(time, voltage, 
    label = diam, color = colors[n])
    plt.legend(frameon = False)

ax1 = plt.subplot(4, 1, 3)
plt.title('Varying capacitance ($\mu$F)')
# the effect of membrane capacitance on input resistance and time constant 
for Cm, n in zip(Cm_list, np.arange(num_color)):
    cell = h.Section(name = 'cell')
    cell.Ra = Ra_default
    diam = diam_default
    cell.cm = Cm
    voltage, time = inject_current(cell = cell, somaLength = 12.6157,
somaDiam = diam, stimDur = 10, stimAmp = 0.05, stimDelay = 10)
    Ri_Cm_list.append(cal_Ri(voltage))
    mTau_Cm_list.append(cal_TauM(voltage, time))
    plt.plot(time, voltage, 
    label = Cm, color = colors[n])
    plt.legend(frameon = False)

ax1 = plt.subplot(4, 1, 4)
plt.title('Varying passive conductance (S)')
# the effect of membrane conductance (resistance) on input resistance and time constant  
for g_pas, n in zip(gpas_list, np.arange(num_color)):
    cell = h.Section(name = 'cell')
    cell.Ra = Ra_default
    diam = diam_default
    cell.cm = Cm_default
    voltage, time = inject_current(cell = cell, somaLength = 12.6157,
somaDiam = diam, stimDur = 10, stimAmp = 0.05, stimDelay = 10,
    g_pas = g_pas)
    Ri_gpas_list.append(cal_Ri(voltage))
    mTau_gpas_list.append(cal_TauM(voltage, time))
    plt.plot(time, voltage, 
    label = g_pas, color = colors[n])
    plt.legend(frameon = False)

plt.show()
```

Above is shown how changing the four different variables effect the membrane voltage.
This give us a good overview of what is happening in our cell and we now proceed to calculate $R_i$ and $\tau_m$.


```{python, include = FALSE}
# checking the effect of changing capacitance
plt.figure()
for Cm in Cm_list:
    cell = h.Section(name = 'cell')
    cell.Ra = Ra_default
    diam = diam_default
    cell.cm = Cm
    voltage, time = inject_current(cell = cell, somaLength = 12.6157,
somaDiam = diam, stimDur = 10, stimAmp = 0.05, stimDelay = 10)
    plt.plot(time, voltage)

plt.show()
```


```{python, include = FALSE}
# checking the effect of changing conductance
plt.figure()
for g_pas in gpas_list:
    cell = h.Section(name = 'cell')
    cell.Ra = Ra_default
    diam = diam_default
    cell.cm = Cm_default
    voltage, time = inject_current(cell = cell, somaLength = 12.6157,
somaDiam = diam, stimDur = 10, stimAmp = 0.05, stimDelay = 5,
    g_pas = g_pas, printProperties = True)
    plt.plot(time, voltage)

plt.show()
```



```{python}
plt.figure(figsize = (12, 20)) 
plt.subplot(4, 2, 1)
plt.plot(Ra_list, Ri_Ra_list)
plt.xlabel('Axial resistance ($\Omega$)')
plt.ylabel('Input resistance ($\Omega$)')
plt.ticklabel_format(style='sci', axis='y', scilimits=(0,0))

plt.subplot(4, 2, 3)
plt.plot(diam_list, Ri_diam_list)
plt.xlabel('Diameter ($\mu$m)')
plt.ylabel('Input resistance ($\Omega$)')
plt.ticklabel_format(style='sci', axis='y', scilimits=(0,0))

plt.subplot(4, 2, 5)
plt.plot(Cm_list, Ri_Cm_list)
plt.xlabel('Capacitance ($\mu$F)')
plt.ylabel('Input resistance ($\Omega$)')
# plt.ylim([1 * (10 ** 8), 2 * (10 ** 8)])
plt.ylim([5 * 10**6, 5.5 * 10**6])
plt.ticklabel_format(style='sci', axis='y', scilimits=(0,0))

plt.subplot(4, 2, 7) 
plt.plot(gpas_list, Ri_gpas_list)
plt.xlabel('Passive conductance (S)')
plt.ylabel('Input resistance ($\Omega$)')
plt.ticklabel_format(style='sci', axis='y', scilimits=(0,0))

plt.subplot(4, 2, 2)
plt.plot(Ra_list, mTau_Ra_list)
plt.xlabel('Axial resistance ($\Omega$)')
plt.ylabel('Time constant (ms)')
plt.ticklabel_format(style='sci', axis='y', scilimits=(0,0))

plt.subplot(4, 2, 4)
plt.plot(diam_list, mTau_diam_list)
plt.xlabel('Diameter ($\mu$m)')
plt.ylabel('Time constant (ms)')
plt.ticklabel_format(style='sci', axis='y', scilimits=(0,0))

plt.subplot(4, 2, 6)
plt.plot(Cm_list, mTau_Cm_list)
plt.xlabel('Capacitance ($\mu$F)')
plt.ylabel('Time constant (ms)')
plt.ticklabel_format(style='sci', axis='y', scilimits=(0,0))

plt.subplot(4, 2, 8) 
plt.plot(gpas_list, mTau_gpas_list)
plt.xlabel('Passive conductance (S)')
plt.ylabel('Time constant (ms)')
plt.ticklabel_format(style='sci', axis='y', scilimits=(0,0))

plt.subplots_adjust(hspace = 0.5, wspace = 0.5)
plt.show()
```
Axial Resistance:
    Has no effect on $R_i$ nor $\tau_m$ because we have a one-compartment model.

Diameter:
    Discussed earlier.

Capacitance:
    Capacitance does not effect the input resistance in this instance because we are changing the capacitance but without changing the cell diameter.
    Capacitance has an effect on $\tau_m$, because $\tau_m$ = $R_m$*$C_m$.
    By increasing the capacitance it now takes longer for the capacitor to charge and as a result the time constant is longer because the less current flows through the resistor whilst the capacitor is charging.

Passive conductances/$R_m$:
    Increasing the passive conductances decreases the membrane resistance (because $R_m$ = 1/g) and as mentioned earlier $R_m$ directly affects $R_i$.
    Reducing the membrane resistance also decreases the time constant as we would expect according to $\tau_m$ = $R_m$*$C_m$.
    In conclusion as we make our membrane more leaky it becomes "easier" to inject current, and it also takes less time to reach peak voltage (although the voltage change from the same current injection will be lower when we have a lower resistance).


## Adding dendrites and axons with increasing total area

```{python, fig.width = 15, figure.height = 5}
from neuron import h, gui
# dendrite_diam_list = [3, 6, 9, 12, 15]
dendrite_diam_list = np.arange(3, 30)
axon_diam_list = [3, 6, 9, 12, 15] 
input_resistance_list = list()
TauM_list = list()

theSoma = h.Section(name='theSoma') 
dend = h.Section(name='dendrite')

# connect dendrite to soma 
dend.connect(theSoma(1)) 
# h.psection()
# h.topology()

# axon = neuron.h.Section(name='axon')
# axon.connect(soma(0))

# inject current
for dend_diam in dendrite_diam_list:
    dend.diam = dend_diam
    # print(dend.psection())
    voltage, time = inject_current(cell = theSoma, somaLength = 12.6157, somaDiam = 12.6157, 
                   stimDur = 10, stimAmp = 0.05, stimDelay = 10, total_time = 25, 
                  printProperties = False)
    input_resistance = cal_Ri(voltage)
    TauM = cal_TauM(voltage, time)
    
    input_resistance_list.append(input_resistance)
    TauM_list.append(TauM)
    
    
import seaborn as sns 
plt.figure(figsize = (12, 7))
plt.subplot(1, 2, 1)
ax = sns.lineplot(dendrite_diam_list, input_resistance_list)
ax.set(xlabel='Dendrite diameter ($\mu$m)', 
       ylabel='Input resistance ($\Omega$)')

plt.subplot(1, 2, 2)
ax = sns.lineplot(dendrite_diam_list, TauM_list)
ax.set(xlabel='Dendrite diameter ($\mu$m)', ylabel='Time constant (ms)')
plt.show()

```



# Active properties 

## Adding HH channels

Add HH Na and K voltage-gated channel to the ball model and inject current steps (add one at a time to see the effectof each one, and then combine).

```{python}
from neuron import h, gui
def make_hh_cell(cellName = 'cell', 
                 gNa = 0.12, gK = 0.036, gL = 0.0003, eL = -54.3, 
                 printProperties = False): 
    """
    makes cell with specified channel conductances
    INPUT 
    gNa | Sodium channel conductance (S / cm2)
    gK  | Potassium channel conductance 
    gL  | Leak conductance 
    eL  | Reversal potential (mV)
    
    Note that default values set in this function are the same as in cell.insert('hh')
    Other implicitly defined properties: 
    ena = 50 
    ek = -77
    cm = 1
    diam = 500, L = 100, Ra = 35.4
    """
    cell = h.Section(name = cellName)
    cell.insert('hh')
    cell.gnabar_hh = gNa
    cell.gkbar_hh = gK 
    cell.gl_hh = gL
    cell.el_hh = eL
    
    if printProperties is True: 
        h.topology()
        h.psection()
    
    return cell
```

### Only adding Na voltage-gated channel

```{python, fig.width = 5, figure.height = 5}
from neuron import h, gui
import seaborn as sns 
    
soma_hh = h.Section(name='soma_hh')
soma_hh.insert('hh')
soma_hh.gnabar_hh = 0.12 # peak sodium conductance
soma_hh.gkbar_hh = 0 # remove sodium conductance 
soma_hh.el_hh = -54.3 # leaak conductance 

# inject current
voltage_np, time_np = inject_current(cell = soma_hh, somaLength = 12.6157,
somaDiam = 12.6157, stimDur = 10, stimAmp = 0.05, stimDelay = 10, total_time = 25)

# plot 
plt.figure(figsize = (10, 8))
ax = sns.lineplot(time_np, voltage_np)
ax.set_title('Adding only Na$^+$ channels')
ax.set(xlabel='Time (ms)', ylabel='Voltage (V)')
sns.despine()
plt.show()
# print(time_np)
```
When we only add sodium channels we see that as current is injected the voltage-gated channels are opened and as a result a sodium spike occurs (just like in a standard AP) after a short period of time the sodium channels inactivate and sodium/current stops flowing.
However the cell is not brought back to its initial membrane potential – which would normally happen when the voltage-gated potassium channels open.
Instead it is brought down to -20 mV where some proportion of sodium channels will be activated and some inactivatedmost likely due to potassium leak conductances and inactivation of sodium channels.


### Only adding K+ voltage-gated channels

```{python, fig.width = 5, figure.height = 5}
k_only_cell = make_hh_cell(cellName = 'cell', gNa = 0, gK = 0.036, gL = 0.0003)

voltage_np, time_np = inject_current(cell = k_only_cell, somaLength = 12.6157,
somaDiam = 12.6157, stimDur = 10, stimAmp = 0.05, stimDelay = 10, total_time = 25)

plt.figure(figsize = (10, 8))
ax = sns.lineplot(time_np, voltage_np)
ax.set_title('Adding only K$^+$ channels')
ax.set(xlabel='Time (ms)', ylabel='Voltage (V)')
sns.despine()
plt.show()
```
There is an initial jump before current injection from -70 to -67 which is because we set our initial membrane potential to -70.
We observe that when current is injected there is a change in membrane potential from -67 to -62, this is before the potassium channels have been activated, then the voltage dips a little once the potassium channels have opened (t = 12 ms) and then when the current injection ends the membrane potential is brought back down -68.
Thus the potassium channels take a little longer to open but work efficiently to somewhat counteract the current injection in the absence of any sodium channels to drive a fast sodium spike.

### Adding both Na+ and K+ voltage-gated channels 

```{python, fig.width = 5, figure.height = 5}
hh_cell = make_hh_cell(cellName = 'hh_cell', gNa =  0.12, gK = 0.036, gL = 0.0003)

voltage_np, time_np = inject_current(cell = hh_cell, somaLength = 12.6157,
somaDiam = 12.6157, stimDur = 10, stimAmp = 0.05, stimDelay = 10, total_time = 25)

# aesthetics()
plt.figure(figsize = (10, 8))
ax = sns.lineplot(time_np, voltage_np)
ax.set_title('Adding both Na$^+$ and K$^+$ channels')
ax.set(xlabel='Time (ms)', ylabel='Voltage (V)')
sns.despine()
plt.show()
```
We observe the initial step until voltage-gated sodium channels are opened which elicits the sodium spike which is then counteracted by the hyperpolarizing currents conferred by the now open voltage-gated potassium channels.

### Measure gNa and gKv as a function of current injection at the soma and plot activation and inactivation curves 

We first define a function to measure the conductance at the soma.

```{python}
from neuron import h, gui 
import seaborn as sns
import matplotlib.pyplot as plt

currMin = 0
currMax = 10
currStep = 1
curr_amp_list = np.arange(currMin, currMax, currStep)
gNa_measured = list()
gKv_measured = list()
max_voltage_list = list()

def record_conductance(cell, somaLength = 12.6157, somaDiam = 12.6157, 
                       stimDur = 10, stimAmp = 0.05, stimDelay = 10, 
                       total_time = 25, vInit = -70,
                       v_clamp_amp1 = 10, v_clamp_amp2 = 30, v_clamp_amp3 = 10,
                       v_clamp_dur1 = 10, v_clamp_dur2 = 20, v_clamp_dur3 = 20,
                  printProperties = False, 
                      injectCurrent = False):
    
    # cell.insert('pas')
    cell.L = somaLength 
    cell.diam = somaDiam
    
    if printProperties is True:
        print('Cell properties')
        h.psection()
        
    cell.insert('hh') # insert HH properties 
    # set Vm
    # cell.el_hh = vInit
    
    # set resting potential 
    # for seg in cell:
    #     seg.hh.el = vInit
    
    if printProperties is True:
        h.psection(cell)
    
    # add point process: current injection 
    if injectCurrent is True:
        stim = h.IClamp(cell(0.5))
        stim.delay = stimDelay
        stim.dur = stimDur # ms
        stim.amp = stimAmp # nA
    
    v_clamp = h.SEClamp(cell(0.5))
    v_clamp.amp1 = v_clamp_amp1
    v_clamp.amp2 = v_clamp_amp2 
    
    # series resistance
    v_clamp.rs = 0.01
    
    v_clamp.dur1 = v_clamp_dur1 
    v_clamp.dur2 = v_clamp_dur2
    v_clamp.dur3 = v_clamp_dur3 
    
    
    # measure voltage 
    voltage = h.Vector()
    voltage.record(cell(0.5)._ref_v)
    
    gNa = h.Vector()
    gNa.record(cell(0.5)._ref_gna_hh)
    
    gKv = h.Vector()
    gKv.record(cell(0.5)._ref_gk_hh)
    
    # measure time
    time = h.Vector()
    time.record(h._ref_t)
    
    # h.v_init = vInit # initial voltage
    # h.finitialize(vInit)
    
    h.load_file('stdrun.hoc')
    h.tstop = total_time
    h.run() # ms
    
    
    return gNa, gKv, voltage, time
```

#### Activation curve 

```{python, figure.width = 10, figure.height = 7}
v_clamp_amp1 = -110
v_clamp_amp2_list = np.arange(-75, 150, 25)

v_clamp_dur1 = 20
v_clamp_dur2 = 30

curr_amp = 0.5

gNa_measured = list()
gKv_measured = list()

# colormap 
import matplotlib.pylab as pl
num_color = len(v_clamp_amp2_list)
colors = pl.cm.viridis(np.linspace(0,1,num_color))

plt.figure(figsize = (20, 7))
ax1 = plt.subplot(1, 2, 1)
ax2 = plt.subplot(1, 2, 2)

for v_clamp_amp2, n in zip(v_clamp_amp2_list, np.arange(num_color)):
    conductance_cell = h.Section(name='conductance_cell')
    gNa, gKv, voltage, time = record_conductance(
    conductance_cell, stimAmp = curr_amp, vInit = v_clamp_amp2,
    stimDelay = 10, total_time = 40,
    v_clamp_amp1 = v_clamp_amp1, v_clamp_amp2 = v_clamp_amp2,
    v_clamp_dur1 = v_clamp_dur1, v_clamp_dur2 = v_clamp_dur2,
    printProperties = False)
    # print(gNa)
    gNa_measured.append(max(gNa))
    gKv_measured.append(max(gKv))


    ax1.plot(time, voltage,
    label = v_clamp_amp2,
             color = colors[n])
    
    # conductance over time 
    ax2.plot(time, gNa,
    label = v_clamp_amp2,
             color = colors[n])

ax1.set_title('Voltage clamp')
ax1.set_xlabel('Time (ms)')
ax1.set_ylabel('Voltage (mV)')

ax2.set_xlabel('Time (ms)')
ax2.set_ylabel('Conductance ($\mu$S)')

plt.show()

```

We used the voltage clamp configuration to determine the sodium conductances.
- something about this!



```{python, fig.width = 10, fig.height = 7}
plt.figure()
ax = sns.lineplot(v_clamp_amp2_list, gKv_measured)
ax.set(xlabel = 'Potential differrence (V)', ylabel = 'Peak conductance ($\mu$S)')
plt.show()
```
The peak sodium condutance plotted against the voltage steps used gives us the activation curve for voltage-gated sodium channels.
- something about that!


#### Inactivation curve

```{python, figure.width = 10, figure.height = 7}
# Vm_list = [-70, -60, -50, -40, -30]
# v_clamp_amp1_list = [-100, -90, -80, -70, -60, 20]
# v_clamp_amp1_list = np.arange(-150, 50, 5)
v_clamp_amp1_list = np.arange(-85, -35, 5)
v_clamp_amp2 = 50

v_clamp_dur1 = 20
v_clamp_dur2 = 30

curr_amp = 0.5

gNa_measured = list()
gKv_measured = list()

aesthetics()
# colormap 
import matplotlib.pylab as pl
num_color = len(v_clamp_amp1_list)
colors = pl.cm.viridis(np.linspace(0,1,num_color))

plt.figure(figsize = (20, 7))
ax1 = plt.subplot(1, 2, 1)
ax2 = plt.subplot(1, 2, 2)

for v_clamp_amp1, n in zip(v_clamp_amp1_list, np.arange(num_color)):
    conductance_cell = h.Section(name='conductance_cell')
    gNa, gKv, voltage, time = record_conductance(conductance_cell, stimAmp = curr_amp, 
    vInit = -70, stimDelay = 10, total_time = 50,
    v_clamp_amp1 = v_clamp_amp1, v_clamp_amp2 = v_clamp_amp2,
    v_clamp_dur1 = v_clamp_dur1, v_clamp_dur2 = v_clamp_dur2,
    printProperties = False)
    gNa_measured.append(max(gNa))
    gKv_measured.append(max(gKv))
    
    ax1.plot(time, voltage, 
             label = v_clamp_amp1,
             color = colors[n])

    ax2.plot(time, gNa,
             label = v_clamp_amp1,
             color = colors[n])

ax1.set_title('Voltage clamp')
ax1.set_xlabel('Time (ms)')
ax1.set_ylabel('Voltage (mV)')

ax2.set_xlabel('Time (ms)')
ax2.set_ylabel('Conductance ($\mu$S)')

# plt.legend(frameon = False, title = 'Initial holding voltage \n (mV)')
plt.show()
```
We also use voltage clamp to determine the changes in sodium conductance, only this time we vary the amplitude of the first clamping voltage.
- something about this!


```{python, fig.width = 10, fig.height = 7}
plt.figure()
ax = sns.lineplot(v_clamp_amp1_list, gNa_measured)
plt.xlabel('Potential differrence (V)')
plt.ylabel('Peak conductance ($\mu$S)')
plt.show()
```

## Play with gNa and gK density to make an action potential 

```{python, fig.width = 10, fig.height = 7}
gNa_custom = 0.12 
gK_custom = 0.036
ap_cell = make_hh_cell(cellName = 'ap_cell', gNa = gNa_custom, gK = gK_custom, gL = 0.0003, eL = -54.3, printProperties = False)
voltage_np, time_np = inject_current(cell = ap_cell, somaLength = 12.6157,
somaDiam = 12.6157, stimDur = 10, stimAmp = 0.05, stimDelay = 10, total_time = 25)

aesthetics()
plt.figure()
ax = sns.lineplot(time_np, voltage_np)
ax.set_title('Action potential using gNa of %.2fS and gK of %.3fS' % (gNa_custom, gK_custom))
ax.set(xlabel='Time (ms)', ylabel='Voltage (V)')
sns.despine()
plt.show()
```

# Synaptic integration


## Add a single alpha excitatory synapse in the soma and then in the dendrite

Progressively far away, and record at the soma. What changes?

Background: 

 - A synapse (for the purpose of this simulation) is a location of transmitter release, which then binds to post-synaptic receptors at the soma to cause change in coductance for one or more ions
  - The conductance change (usually increase) can be described by a mathematical function 
  - An alpha synapse is a synapse in which the conductance change in the post-synapse cell can be described by the *alpha function* 
 - In `NEURON`, the alpha synapse is a point process (ie. it is assumed to be a point source of current along the cell)
  
There seems to be multiple mathematical definition of the alpha function, and `NEURON` implements the alpha function (see ref 3) via:

$$
g(t) = g_\text{max} \alpha t e^{1 - \alpha t}
$$
  
References: 

 - [AlphaSynapse](http://fohs.bgu.ac.il/nia/nia2003/neurolab/help/alphasyn.htm)
 - [Alpha function, Wolfram](http://mathworld.wolfram.com/AlphaFunction.html)
 - [NEURON forum on alpha function](https://www.neuron.yale.edu/phpBB/viewtopic.php?t=2982)
 

We first define functions to make a cell with alpha synapse directed to the dendrite and to record the potential at the soma.

```{python}
from neuron import h, gui
import seaborn as sns 
import matplotlib.pyplot as plt

def sim_alpha_synapse(alpha_loc = 0.5, record_loc = 0.5, simDur = 40, vInit = -70, 
                      alpha_onset = 20, alpha_gmax = 1, printProperties = False, 
                      nSomaSegment = 1, nDendSegment = 300,
                     somaLength = 1000, recordSegment = 'soma', 
                      dendriteNum = 0):
    """
    Create alpha synapse, then simulate to record potential difference over time
    INPUT 
    alpha_loc  | location of inserting alpha syanapse 
    record_loc | location of recording the alpha synapse
    simDur     | duration of the simulation (ms)
    """
    soma = h.Section(name='soma')
    soma.insert('pas')
    
    soma.L = 20 #somaLength
    soma.diam = 20 #
    
    # alpha synapse on soma
    # soma.nseg = nSomaSegment
    # asyn = h.AlphaSynapse(soma(alpha_loc))
    
    # alpha synapse on dendrite 
    dend = h.Section(name = 'dend')
    dend.L = 300
    dend.diam = 1
    dend.nseg = nDendSegment 
    asyn = h.AlphaSynapse(dend(alpha_loc))
    dend.connect(soma(0))
    
    asyn.onset = alpha_onset
    asyn.gmax = alpha_gmax
    
    
    if printProperties is True: 
        h.psection(soma)
        h.psection(dend)
        # print(dir(asyn))
    
    v_vec = h.Vector()             # Membrane potential vector
    t_vec = h.Vector()             # Time stamp vector
    if recordSegment == 'soma':
        # print('Recording at the soma')
        v_vec.record(soma(record_loc)._ref_v)
    elif recordSegment == 'dendrite':
        # print('Recording at the dendrite')
        v_vec.record(dend(record_loc)._ref_v)
    t_vec.record(h._ref_t)
    h.v_init = vInit
    h.tstop = simDur
    h.run()
    return t_vec, v_vec
```

Then we run the simulation:

```{python, fig.width = 10, fig.height = 7}
time, voltage = sim_alpha_synapse()
import matplotlib.pyplot as plt
plt.figure()
plt.plot(time, voltage)
plt.xlabel('Time (ms)')
plt.ylabel('Potential difference (mV)')
plt.show()
```

### Moving the alpha synapse progressively far away 

```{python, fig.width = 10, fig.height = 7}
# progressively far away alpha synapse 
location_list = [0.1, 0.2, 0.3, 0.4, 0.5]
alpha_onset_list = [1, 5, 10, 15, 20]
peak_voltage = []

# colormap 
import matplotlib.pylab as pl
num_color = len(location_list)
colors = pl.cm.viridis(np.linspace(0,1,num_color))

plt.figure()
for loc, n in zip(location_list, np.arange(num_color)):
    time, voltage = sim_alpha_synapse(alpha_loc = loc, record_loc = 0.5, simDur = 40, 
                                      nSomaSegment = 100, somaLength = 1000,
                                      alpha_gmax = 0.5, 
                                      printProperties = False)
    sns.lineplot(time, voltage, 
                 label = loc, 
                 color = colors[n])
    peak_voltage.append(max(voltage) - min(voltage))
    plt.xlabel('Time (ms)')
    plt.ylabel('Potential difference (mV)')

plt.ylim([-70, 0])
plt.legend(frameon=False, title = 'Relative distance \n from soma (au)')
plt.show()
```

```{python, fig.width = 10, fig.height = 7}
# plot the peak potential difference against the distance 
plt.figure()
sns.lineplot(location_list, peak_voltage)
plt.ylabel('Deploarising change in potential difference (mV)')
plt.xlabel('Distance from the soma (au)')
plt.show()
```
The amplitude of the voltage change elicted by the alphasynapse decreases with distance due to the passive properties of the cell, (axial resistance combined with a leaky membrane).
As a result when the alphasynapse is further away from the soma the depolarising change recorded at the soma is smaller, because the signal attenuates as it travels along the dendrite.

## Record at the dendrite where the synapse is whilst moving the alpha synapse progressively far away

```{python, fig.width = 10, fig.height = 7}
plt.figure()
location_list = [0.1, 0.2, 0.3, 0.4, 0.5]

# colormap 
import matplotlib.pylab as pl
num_color = len(location_list)
colors = pl.cm.viridis(np.linspace(0,1,num_color))

for loc, n in zip(location_list, np.arange(num_color)):
    # print(loc)
    time, voltage = sim_alpha_synapse(alpha_loc = loc, record_loc = 0.5, simDur = 40, 
                                      nSomaSegment = 100, somaLength = 1000,
                                      alpha_gmax = 0.5, recordSegment = 'dendrite',
                                      printProperties = False)
    sns.lineplot(time, voltage, 
                 label = loc, 
                 color = colors[n])
    # peak_voltage.append(max(voltage) - min(voltage))
    plt.xlabel('Time (ms)')
    plt.ylabel('Potential difference (mV)')

plt.ylim([-70, 0])
plt.legend(frameon=False, title = 'Relative distance from \n centre of dendrite ($\mu$m)', 
           loc = 'upper right')
plt.show()
```
When we record the voltage at the dendrite as the alphasynapse is activated we observe that the amplitude of the voltage change is higher than when the synapse was on the soma.
The higher voltage change is due to the dendrites smaller size and thus higher input resistance.

# Appendix 

## Varying multiple variables simultaneously 

We iterate through each of these list, running our simulations and calculating input resistance and time constants as above.

```{python, eval = FALSE}
import itertools
import pandas as pd
# variable lists
diam_list = [3, 6, 9, 12, 15]
Cm_list = [0.1, 0.3, 0.6, 1.0, 1.3]
Ri_list = list()
mTau_list = list()

# using ranges 
Ra_list = np.arange(10, 50, 2)
Cm_list = np.arange(0.1, 1.3, 0.1)


# varying all 3 variables
# variableCart, variableIter = itertools.tee(
# itertools.product(Ra_list, diam_list, Cm_list))
# cartesian product of the variables
# using tee to make two copies of the same iterator so I can use it twice

# varying just 2 variables 
diam = 3
variableCart, variableIter = itertools.tee(itertools.product(Ra_list, Cm_list))


# df = pd.DataFrame(list(variableCart),
#                   columns = ['Ra', 'Diam', 'Cm'])

df = pd.DataFrame(list(variableCart),
                  columns = ['Ra', 'Cm'])

for var_list in variableIter:
    cell = h.Section(name = 'cell')
    # 3 variables
    # cell.Ra = var_list[0] # axial resistance
    # diam = var_list[1]
    # cell.cm = var_list[2]
    
    # 2 variables 
    cell.Ra = var_list[0]
    cell.cm = var_list[1]
    diam = 50000 # default to 500
    
    voltage, time = inject_current(cell = cell, somaLength = 12.6157,
somaDiam = diam, stimDur = 10, stimAmp = 0.05, stimDelay = 10)
    Ri_list.append(cal_Ri(voltage))
    mTau_list.append(cal_TauM(voltage, time))

df['Ri'] = Ri_list
df['mTau'] = mTau_list
    
# print preview of the table
# df
```

```{python, fig.width = 10, fig.height = 7, eval = FALSE}
Cm_list = np.arange(0.1, 2, 0.1)
diam_list = np.arange(250, 252, 0.1) # default diam = 500

# lists to store input resistance and time constant
Ri_list = list()
mTau_list = list()


variableCart, variableIter = itertools.tee(itertools.product(Cm_list, diam_list))

df = pd.DataFrame(list(variableCart),
                  columns = ['Capacitance', 'Diameter'])

for var_list in variableIter:
    cell = h.Section(name = 'cell')
    
    # 2 variables 
    # cell.insert('pas')
    # cell.g_pas = var_list[0]
    # diam = var_list[1]
    
    cell.cm = var_list[0] # default capacitance 
    cell.Ra = 35.4 # default axial resistance
    diam = var_list[1]
    
    voltage, time = inject_current(cell = cell, somaLength = 12.6157,
somaDiam = diam, stimDur = 10, stimAmp = 0.05, stimDelay = 10)
    Ri_list.append(cal_Ri(voltage))
    mTau_list.append(cal_TauM(voltage, time))

df['Ri'] = Ri_list
df['mTau'] = mTau_list

# 3D surface plot to show the effect of the 2 variables on input resistance 
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns

# Make the plot
# fig = plt.figure(figsize=(8, 6), dpi = 300)
fig = plt.figure(figsize=(10, 7))
ax = fig.gca(projection='3d')
ax.plot_trisurf(df['Capacitance'], df['Diameter'], df['Ri'], 
                cmap=plt.cm.viridis, linewidth=0,
                edgecolor='none',
                antialiased=True)
ax.set(xlabel='Capacitance ($\mu$F/cm$^2$)', ylabel='Diameter ($\mu$ m)',
      zlabel = 'Input resistance ($\Omega$)')
# plt.show()
 
# to Add a color bar which maps values to colors.
# surf=ax.plot_trisurf(df['Capacitance'], df['Diameter'], df['Ri'], 
#                      cmap=plt.cm.viridis, linewidth=0.2)
# fig.colorbar(surf, shrink=0.5, aspect=5)
# plt.show()

# padding for axis 
ax.xaxis.labelpad = 20
ax.yaxis.labelpad = 20
ax.zaxis.labelpad = 20

# change the label so it doens't overlap
ax.set_zlabel(zlabel='$R_i$')

# padding for tick marks
ax.ticklabel_format(axis = 'z', style = 'sci', scilimits = [0, 0])
ax.tick_params(axis = 'z', pad = 10)
 
# Rotate it
ax.view_init(45, 45)
plt.show()
```

```{python, fig.width = 10, fig.height = 7, eval = FALSE}
# 3D surface plot to show the effect of the 2 variables on input resistance 
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns

# Make the plot
fig = plt.figure(figsize=(8, 6))
fig = plt.figure()
ax = fig.gca(projection='3d')
ax.plot_trisurf(df['Ra'], df['Cm'], df['Ri'], cmap=plt.cm.viridis, linewidth=0.2)
ax.set(xlabel='Axial resistance ($\Omega$)', 
       ylabel='Membrane capicitance ($\mu$F/cm$^2$)',
      zlabel = 'Input resistance ($\Omega$)')
# plt.show()
 
# to Add a color bar which maps values to colors.
surf=ax.plot_trisurf(df['Ra'], df['Cm'], df['Ri'], cmap=plt.cm.viridis, linewidth=0.2)
# fig.colorbar(surf, shrink=0.5, aspect=5) # toggle colorbar
# plt.show()

# padding for axis 
ax.xaxis.labelpad = 20
ax.yaxis.labelpad = 20
ax.zaxis.labelpad = 20

# padding for tick mark 
ax.tick_params(axis = 'z', pad = 10)

# Rotate it
ax.view_init(45, 45)
plt.show()
```


## Holding all variables except one

```{python, fig.width = 12, fig.height = 14, eval = FALSE}
# based on: https://matplotlib.org/gallery/ticks_and_spines/multiple_yaxis_with_spines.html
# but instead of twinx, I am using twiny, and so the top rather than right axis is reset
import matplotlib.pyplot as plt

aesthetics(font_scale = 2, line_width = 3) # 2, 3

def make_patch_spines_invisible(ax):
    ax.set_frame_on(True)
    ax.patch.set_visible(False)
    for sp in ax.spines.values():
        sp.set_visible(False)


fig, host = plt.subplots()
fig.subplots_adjust(right=0.75)

par1 = host.twiny()
par2 = host.twiny()

# Offset the right spine of par2.  The ticks and label have already been
# placed on the right by twinx above.
# par2.spines["right"].set_position(("axes", 1.2))
par2.xaxis.set_ticks_position('bottom') # set the position of the second x-axis to bottom
par2.xaxis.set_label_position('bottom') # set the position of the second x-axis to bottom

par2.spines["bottom"].set_position(('axes', -0.2))

# Having been created by twinx, par2 has its frame off, so the line of its
# detached spine is invisible.  First, activate the frame but make the patch
# and spines invisible.
make_patch_spines_invisible(par2)

# Second, show the right spine.
# par2.spines["right"].set_visible(True)
par2.spines["bottom"].set_visible(True)

p1, = host.plot(Ra_list, Ri_Ra_list, "b-", label="Axial resistance")
p2, = par1.plot(diam_list, Ri_diam_list, "r-", label="Diameter")
p3, = par2.plot(Cm_list, Ri_Cm_list, "g-", label="Membrane capacitance")

host.set_xlabel("Axial resistance ($\Omega$)")
host.set_ylabel("Input resistance ($\Omega$)")
par1.set_xlabel('Diameter ($\mu$m)')
par2.set_xlabel('Capacitance ($\mu$F)')

host.xaxis.label.set_color(p1.get_color())
par1.xaxis.label.set_color(p2.get_color())
par2.xaxis.label.set_color(p3.get_color())

tkw = dict(size=4, width=1.5)
host.tick_params(axis='x', colors=p1.get_color(), **tkw)
par1.tick_params(axis='x', colors=p2.get_color(), **tkw)
par2.tick_params(axis='x', colors=p3.get_color(), **tkw)
host.tick_params(axis='y', **tkw)

lines = [p1, p2, p3]

host.legend(lines, [l.get_label() for l in lines], frameon = False)
plt.subplots_adjust(bottom = 0.5) # adjust bottom margin to show second bottom x-axis
plt.show()
```


